{"version":3,"sources":["transposer.js"],"names":[],"mappings":"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","file":"transposer-compiled.js","sourcesContent":["/**\r\n * Frigidrain transposer\r\n */\r\nvar XRegExp = require('xregexp');\r\n\r\n/*\r\nmodule.exports = {\r\n  transpose: function(text) {\r\n    return new Text(text);\r\n  },\r\n}; */\r\n\r\n/**\r\n * Object which holds information about the text. The text is transposed and\r\n * returned when up, down or toKey is called.\r\n */\r\nfunction Text(text) {\r\n  var text = text;\r\n  var currentKey = null;\r\n  var formatter = null;\r\n\r\n  this.fromKey = function(key) {\r\n    currentKey = key;\r\n    return this;\r\n  };\r\n  \r\n  this.withFormatter = function(fmt) {\r\n    formatter = fmt;\r\n    return this;\r\n  };\r\n\r\n  this.up = function(n) {\r\n    return transpose(text, semitoneMapper(n), currentKey, formatter);\r\n  };\r\n\r\n  this.down = function(n) {\r\n    return transpose(text, semitoneMapper(-n), currentKey, formatter);\r\n  };\r\n\r\n  this.toKey = function(key) {\r\n    return transpose(text,\r\n        function(currentKey) { return key; },\r\n        currentKey,\r\n        formatter);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a function that when given a key, will return the key the given\r\n * number of semitones higher/lower.\r\n */\r\nfunction semitoneMapper(semitones) {\r\n  return function(currentKey) {\r\n    return transposeKey(currentKey, semitones);\r\n  };\r\n}\r\n\r\n/**\r\n * Transposes text into another key which is given by the mapper function.\r\n *\r\n * The mapper function is a function that takes a key signature and gives the\r\n * target key signature to be transposed into. If currentKey is unknown, we take\r\n * the first chord we see as the key signature.\r\n */\r\nfunction transpose(text, mapper, currentKey, formatter) {\r\n  if (formatter == null) {\r\n    formatter = defaultFormatter;\r\n  }\r\n\r\n  // Initialize the variables.\r\n  var newText = [],\r\n    newKey, curId = 0,\r\n    parts, table = {},\r\n    map;\r\n\r\n  /**\r\n   * Saves the given symbol in the table.\r\n   */\r\n  function cacheSymbol(symbol, colourId) {\r\n    table[tokens[i]] = {};\r\n    table[tokens[i]].symbol = symbol;\r\n    table[tokens[i]].colour = colourId;\r\n  }\r\n\r\n  // Split the text by parts.\r\n  var lines = text.split(\"\\n\");\r\n\r\n  // If current key is known, generate map.\r\n  if (currentKey) {\r\n    newKey = mapper(currentKey);\r\n    map = transpositionMap(currentKey, newKey);\r\n  }\r\n\r\n  // Iterate lines.\r\n  for (k = 0; k < lines.length; k++) {\r\n    var newLine = \"\",\r\n      chordCount = 0,\r\n      tokenCount = 0;\r\n    var tokens = lines[k].split(/(\\s+)/g);\r\n\r\n    for (var i = 0; i < tokens.length; i++) {\r\n      // Check for all whitespace.\r\n      if (tokens[i].trim() === '') {\r\n        newLine += tokens[i];\r\n        continue;\r\n      }\r\n\r\n      if (tokens[i] in table) {\r\n        newLine += formatter(table[tokens[i]].symbol, table[tokens[i]].colour);\r\n        chordCount++;\r\n        continue;\r\n      }\r\n\r\n      // If symbol is chord, transpose it.\r\n      if (chordPattern.test(tokens[i])) {\r\n        parts = parse(tokens[i]);\r\n        // If current key is unknown, set the first seen chord to the current key.\r\n        if (!currentKey) {\r\n          // If the first chord is minor, find its major equivalent.\r\n          if (parts.suffix == 'm' || parts.suffix == 'min') {\r\n            currentKey = minors[parts.chord];\r\n          } else {\r\n            currentKey = parts.chord;\r\n          }\r\n          newKey = mapper(currentKey);\r\n          map = transpositionMap(currentKey, newKey);\r\n        }\r\n        var symbol = transposeToken(map, parts);\r\n        cacheSymbol(symbol, curId);\r\n        newLine += formatter(symbol, curId);\r\n        curId++;\r\n        chordCount++;\r\n        // If symbol is not chord, just add it.\r\n      } else {\r\n        newLine += tokens[i];\r\n        tokenCount++;\r\n      }\r\n    }\r\n    if (chordCount > tokenCount / 2) {\r\n      newText.push(newLine);\r\n    } else {\r\n      newText.push(lines[k]);\r\n    }\r\n  }\r\n  if (!newKey) {\r\n    throw new Error('No valid chords were found for default key signature.');\r\n  }\r\n  return {\r\n    text: newText.join('\\n'),\r\n    key: newKey,\r\n  };\r\n}\r\n\r\nfunction parse(sym) {\r\n  return XRegExp.exec(sym, chordPattern);\r\n}\r\n\r\n/**\r\n * Transposes the token given its parts.\r\n */\r\nfunction transposeToken(map, parts) {\r\n  try {\r\n    var chord = map[parts.chord];\r\n    var suffix = (parts.suffix === undefined) ? \"\" : parts.suffix;\r\n    var bass = (parts.bass === undefined) ? \"\" : map[parts.bass];\r\n  } catch (err) {\r\n    alert(err);\r\n    return \"\";\r\n  }\r\n  if (bass) {\r\n    return chord + suffix + \"/\" + bass;\r\n  } else {\r\n    return chord + suffix;\r\n  }\r\n}\r\n\r\n/**\r\n * Given the current key and the number of semitones to transpose, returns a\r\n * mapping from each note to a transposed note.\r\n */\r\nfunction transpositionMap(currentKey, newKey) {\r\n  var map = {};\r\n  // Get the number of semitones.\r\n  semitones = semitonesBetween(currentKey, newKey);\r\n\r\n  // Find out whether new key is sharp of flat.\r\n  if (keys[newKey][\"flats\"] > 0) {\r\n    scale = flats;\r\n  } else {\r\n    scale = sharps;\r\n  }\r\n\r\n  for (var i = 0; i < N_KEYS; i++) {\r\n    map[flats[i]] = scale[(i + semitones + N_KEYS) % N_KEYS];\r\n    map[sharps[i]] = scale[(i + semitones + N_KEYS) % N_KEYS];\r\n  }\r\n  return map;\r\n}\r\n\r\nfunction semitonesBetween(a, b) {\r\n  if (!(a in keys)) {\r\n    throw new Error(a + \" is not a valid key signature.\");\r\n  }\r\n  if (!(b in keys)) {\r\n    throw new Error(b + \" is not a valid key signature.\");\r\n  }\r\n  return keys[b][\"index\"] - keys[a][\"index\"];\r\n}\r\n\r\n/**\r\n * Finds the key that is a specified number of semitones above/below the current key.\r\n */\r\nfunction transposeKey(currentKey, semitones) {\r\n  if (!(currentKey in keys)) {\r\n    throw new Error(currentKey + \" is not a valid key signature.\");\r\n  }\r\n  var newInd = (keys[currentKey][\"index\"] + semitones + N_KEYS) % N_KEYS;\r\n  for (var k in keys) {\r\n    if (keys[k][\"index\"] == newInd) {\r\n      return k;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction defaultFormatter(text, id) {\r\n  return text;\r\n}\r\n\r\n// List of chords using flats.\r\nvar flats = [\"C\", \"Db\", \"D\", \"Eb\", \"E\", \"F\", \"Gb\", \"G\", \"Ab\", \"A\", \"Bb\", \"Cb\"];\r\n\r\n// List of chords using sharps.\r\nvar sharps = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\r\n\r\n// List of key signatures and some data about each.\r\nvar keys = {\r\n  \"C\": {\r\n    index: 0,\r\n    sharps: 0,\r\n    flats: 0\r\n  },\r\n  \"Db\": {\r\n    index: 1,\r\n    sharps: 0,\r\n    flats: 5\r\n  },\r\n  \"D\": {\r\n    index: 2,\r\n    sharps: 2,\r\n    flats: 0\r\n  },\r\n  \"Eb\": {\r\n    index: 3,\r\n    sharps: 0,\r\n    flats: 3\r\n  },\r\n  \"E\": {\r\n    index: 4,\r\n    sharps: 4,\r\n    flats: 0\r\n  },\r\n  \"F\": {\r\n    index: 5,\r\n    sharps: 0,\r\n    flats: 1\r\n  },\r\n  \"Gb\": {\r\n    index: 6,\r\n    sharps: 0,\r\n    flats: 6\r\n  },\r\n  \"G\": {\r\n    index: 7,\r\n    sharps: 1,\r\n    flats: 0\r\n  },\r\n  \"Ab\": {\r\n    index: 8,\r\n    sharps: 0,\r\n    flats: 4\r\n  },\r\n  \"A\": {\r\n    index: 9,\r\n    sharps: 3,\r\n    flats: 0\r\n  },\r\n  \"Bb\": {\r\n    index: 10,\r\n    sharps: 0,\r\n    flats: 2\r\n  },\r\n  \"B\": {\r\n    index: 11,\r\n    sharps: 5,\r\n    flats: 0\r\n  }\r\n};\r\n\r\n// Maps each minor key to its major equivalent.\r\nvar minors = {\r\n  \"C\": \"Eb\",\r\n  \"Db\": \"F\",\r\n  \"D\": \"F\",\r\n  \"Eb\": \"Gb\",\r\n  \"E\": \"G\",\r\n  \"F\": \"Ab\",\r\n  \"F#\": \"A\",\r\n  \"G\": \"Bb\",\r\n  \"Ab\": \"Cb\",\r\n  \"A\": \"C\",\r\n  \"Bb\": \"Db\",\r\n  \"B\": \"D\"\r\n};\r\n\r\nvar N_KEYS = 12;\r\n\r\n// Regex for recognizing chords\r\nvar chordPattern = XRegExp('^(?<chord>[A-G](#|b)?)(?<suffix>(\\\\(?(M|maj|major|m|min|minor|dim|sus|dom|aug|\\\\+|-|add)?\\\\d*\\\\)?)*)(\\\\/(?<bass>[A-G](#|b)?))?$');\r\n"]}